package com.xuhj.classfeaturepractise;

public class JavaExtendPra {
    /**
     * 继承由来,static和private都不能被子类继承
     * 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要 继承那一个类即可。
     * 继承:就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 访问父类中的非私有的属性和行为。
     * 好处
     * 1. 提高代码的复用性。
     * 2. 类与类之间产生了关系，是多态的前提。
     * 3.在子类的成员方法中可以直接调用父类中public中的成员方法，可以这么想，继承了父类之后，父类中的public成员方法就是在子类的方法栈当中了，可以当成自己的方法来用，如果存在同名覆盖方法，那么调用的就是子类的成员方法。但是在main方法中存在父类和子类的成员方法，所以必须新建对象才能调用
     * 继承后的特点——成员变量 如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。
     * 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰 父类成员变量，类似于之前学过的 this 。如果不加的话默认的是子类的东西
     * Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能 直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员 变量呢?对!可以在父类中提供公共的getXxx方法和setXxx方法。
     * 成员方法不重名  继承中调用方法 先去子类中找，没有再去父类找
     * 如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对 应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法
     * 成员方法重名——重写(Override) 如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。
     * 方法重写 :子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)，会出现覆盖效 果，也称为重写或者复写。声明不变，重新实现。
     * 抽象类
     * 由来
     * 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法 的类就是抽象类。
     * 定义
     * 抽象方法 : 没有方法体的方法。 抽象类:包含抽象方法的类。
     *
     * 成员变量和局部变量的差别
     * 在类中的位置不同 重点 成员变量:类中，方法外
     * 局部变量:方法中或者方法声明上(形式参数) 作用范围不一样 重点
     * 成员变量:类中 局部变量:方法中
     * 初始化值的不同 重点
     * 成员变量:有默认值 局部变量:没有默认值。必须先定义，赋值，最后使用
     * 在内存中的位置不同 了解
     * 成员变量:堆内存 局部变量:栈内存
     * 生命周期不同 了解
     * 成员变量:随着对象的创建而存在，随着对象的消失而消失 局部变量:随着方法的调用而存在，随着方法的调用完毕而消失
     *
     *
     *
     * */

    public static void main(String[] args) {

    }
}
